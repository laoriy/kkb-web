<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>canvas绘图</title>
</head>
<style>
    #canvas {
        background-color: rgb(207, 204, 18);
        /* background: #000; */
    }
</style>

<body>
    <!-- <video id="vid" controls autoplay loop muted>
        <source src="./assets/move.mp4" type='video/mp4'>
    </video> -->
    <canvas id="canvas" width="800" height="700"></canvas>
    <!-- <script>
        /* font */
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        // 竖直线
        ctx.beginPath()
        ctx.setLineDash([8, 8])
        ctx.strokeStyle = '#999'
        ctx.moveTo(200, 50)
        ctx.lineTo(200, 500)
        ctx.stroke()

        ctx.font = 'bold 36px Arial'
        ctx.textAlign = 'start'
        ctx.fillText('start', 200, 50)
        ctx.textAlign = 'end'
        ctx.fillText('end', 200, 100)
        ctx.textAlign = 'left'
        ctx.fillText('left', 200, 150)
        ctx.textAlign = 'right'
        ctx.setLineDash([2, 2])
        ctx.strokeStyle = 'red'
        ctx.strokeText('right', 200, 200)
        ctx.textAlign = 'center'
        ctx.fillText('centercentercentercenter', 200, 250, 200)

        // 水平线
        ctx.beginPath()
        ctx.setLineDash([8, 8])
        ctx.strokeStyle = '#999'
        ctx.moveTo(50, 400)
        ctx.lineTo(500, 400)
        ctx.stroke()

        ctx.textAlign = 'left'
        ctx.textBaseline = 'top'
        ctx.fillText('top', 50, 400)
        ctx.textBaseline = 'middle'
        ctx.fillText('middle', 150, 400)
        ctx.textBaseline = 'bottom'
        ctx.fillText('bottom', 250, 400)

        //文字内容
        const text = 'canvas-------------';
        //矩形左上角位置
        const [x, y] = [50, 550];
        //矩形宽度
        const height = 60;

        ctx.setLineDash([])
        //字体
        ctx.font = '36px Arial';
        //水平居中
        ctx.textAlign = 'center';
        //垂直居中
        ctx.textBaseline = 'middle';
        //文字宽度
        const width = ctx.measureText(text).width + 36;
        //绘制矩形
        ctx.strokeRect(x, y, width, height);
        //绘制文字
        ctx.fillText(text, x + width / 2, y + height / 2);

    </script> -->

    <!-- <script>
        /* 布艺文字 */
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        // 投影
        ctx.shadowColor = 'rgba(0,0,0,0.6)'
        ctx.shadowBlur = 4
        ctx.shadowOffsetY = 2
        // 文本
        ctx.font = 'bold 200px Arial'
        ctx.fillStyle = '#a76921'
        ctx.fillText('canvas', 50, 150)
        // 实体描边
        ctx.strokeStyle = '#f0d5ac'
        ctx.lineWidth = 9
        ctx.strokeText('canvas', 50, 150)

        // 虚线描边

        ctx.strokeStyle = '#333'
        ctx.setLineDash([5, 3])
        ctx.lineWidth = 1
        ctx.strokeText('canvas', 50, 150)

    </script> -->

    <!-- <script>
        /* 夜巴黎 */
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        //颜色数组
        const colors = ['red', 'yellow'];
        const dashOffset = [0, 6];
        const states = [0, 1];
        function draw() {
            ctx.save();
            //偏移坐标系
            ctx.beginPath();
            ctx.strokeStyle = colors[states[0]];
            ctx.lineWidth = 3;
            ctx.setLineDash([6]);
            ctx.lineDashOffset = dashOffset[states[0]];
            ctx.font = 'bold 200px arial';
            ctx.shadowColor = 'orange';
            for (let i = 8; i > 0; i -= 1) {
                ctx.shadowBlur = i;
                ctx.strokeText('夜巴黎', 80, 250);
            }
            ctx.restore();
        }

        setInterval(function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            draw();
            states.reverse();
        }, 500);

    </script> -->
    <!-- <script>
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        /* 图片  */
        // const img = new Image()
        // img.src = './assets/dog.jpg'
        // img.onload = () => {
        //     // 相机视图缩小，实际看到的图是放大的,后面四个参数是对裁剪后的图进行位置大小摆放
        //     ctx.drawImage(img, img.width / 2, 0, img.width / 2, img.height, 100, 50, img.width, img.height)
        // }


        /* 播放视频 */

        // let interval = null;
        // vid.addEventListener('play', function () {
        //     interval = setInterval(function () {
        //         ctx.drawImage(vid, 0, 0);
        //     }, 40);
        // })
        // vid.addEventListener('pause', function () {
        //     clearInterval(interval);
        // })


        /* 雪碧图 */
        // 图片数量
        const len = 8
        // 宽高256
        const size = 256

        let fm = 0 // 当前帧

        const img = new Image()
        img.src = './assets/bomb.jpg'
        function draw() {
            ctx.drawImage(img, fm * size, 0, size, size, 0, 0, size, size)
            fm++;
            if (fm === len) {
                fm = 0
            }
        }
        img.onload = draw

        setInterval(() => {
            draw()
        }, 100)
    </script> -->

    <!-- <script>
        /** imageData **/
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        // 1.
        // const imgData = new ImageData(200, 200)
        // imgData.data.forEach((ele, index) => {
        //     imgData.data[index] = 100
        // })
        // ctx.putImageData(imgData, 0, 0)

        // 2.
        // const imgData = ctx.createImageData(200, 200)
        // imgData.data.forEach((ele, index) => {
        //     imgData.data[index] = 100
        // })
        // ctx.putImageData(imgData, 0, 0)

        /*
        * 3.获取canvas中的像素
        */

        // const imageData2 = ctx.getImageData(0, 0, 1, 1)
        // console.log(imageData2);


        // 4.
        const img = new Image()
        img.src = './assets/dog.jpg'
        img.onload = () => {
            const { width, height } = img
            /* 绘制图形 */
            ctx.drawImage(img, 0, 0)
            /* 获取图像imgData */
            const imgData = ctx.getImageData(0, 0, width, height)
            /* 修改像素 */
            const data = imgData.data
            for (let i = 0; i < data.length; i += 4) {
                data[i + 1] = 0
            }

            /* 显示imgData */
            // ctx.putImageData(imgData, 0, height, 50, 50, 200, 200)
            ctx.putImageData(imgData, 0, height)

        }
    </script> -->

    <!-- <script>
        /** imageData **/
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        const img = new Image()
        /* 变灰 */
        // img.src = './assets/river.jpg'
        // img.onload = () => {
        //     const { width, height } = img
        //     /* 绘制图形 */
        //     ctx.drawImage(img, 0, 0)
        //     /* 获取图像imgData */
        //     const imgData = ctx.getImageData(0, 0, width, height)
        //     /* 修改像素 */
        //     const data = imgData.data
        //     for (let i = 0; i < data.length; i += 4) {
        //         const [r, g, b] = [data[i], data[i + 1], data[i + 2]]

        //         const lm = 0.299 * r + 0.587 * g + 0.114 * b;
        //         data[i] = data[i + 1] = data[i + 2] = lm

        //     }

        //     /* 显示imgData */
        //     // ctx.putImageData(imgData, 0, height, 50, 50, 200, 200)
        //     ctx.putImageData(imgData, 0, height)

        // }

        // /* 马赛克 */

        img.src = './assets/wns.jpg'
        img.onload = () => {
            const { width, height } = img
            /* 绘制图形 */
            ctx.drawImage(img, 0, 0)
            /* 获取图像imgData */
            const imgData = ctx.getImageData(0, 0, width, height)
            /* 修改像素 */
            const data = imgData.data
            const size = 8
            for (let y = 0; y < height; y += size) {
                for (let x = 0; x < width; x += size) {
                    const rIndex = (y * width + x) * 4
                    const [r, g, b] = [data[rIndex], data[rIndex + 1], data[rIndex + 2]]
                    ctx.fillStyle = `rgb(${r},${g},${b})`
                    ctx.fillRect(x, y, size, size)
                }
            }
        }

        /*边缘算法*/
        // function roberts(width, height) {
        //     //获取像素点阵
        //     var imageData = ctx.getImageData(0, 0, width, height);
        //     console.log(imageData);
        //     var pixelData = imageData.data;

        //     //算法核心
        //     for (var i = 0; i < height - 1; i++) {
        //         for (var j = 0; j < width - 1; j++) {
        //             //获取需要像素下标
        //             var target = 4 * (i * width + j); //左上
        //             var member1 = 4 * (i * width + j + 1); //右上
        //             var member2 = 4 * ((i + 1) * width + j); //左下
        //             var member3 = 4 * ((i + 1) * width + j + 1); //右下

        //             for (var k = 0; k < 3; k++) {
        //                 var gx = pixelData[target + k] - pixelData[member3 + k];
        //                 var gy = pixelData[member1 + k] - pixelData[member2 + k];
        //                 var vc = Math.abs(gx) + Math.abs(gy);
        //                 pixelData[target + k] = vc;
        //             }

        //         }
        //     }

        //     ctx.putImageData(imageData, 0, 0, 0, 0, width, height);
        // }

        // img.src = './assets/wns.jpg'
        // img.onload = () => {
        //     const { width, height } = img
        //     ctx.drawImage(img, 0, 0)
        //     roberts(width, height)
        // }


    </script> -->

    <!-- <script>

        /** 状态管理 变换**/
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        ctx.save()
        ctx.fillStyle = 'red'
        ctx.fillRect(0, 0, 100, 100)
        ctx.restore()
        ctx.translate(100, 100)
        ctx.rotate(Math.PI / 4)
        ctx.scale(0.5, 0.5)
        ctx.fillRect(0, 100, 100, 100)
    </script> -->
    <script>

        /** 时钟**/
        // 没有提示代码解决
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        // 色系
        const [redA, redB, yellow] = ['#db655c', '#d63d46', '#9f8d7d']
        // 一圈的弧度
        const c = Math.PI * 2
        // canvas宽高
        const { width, height } = canvas

        draw()
        function draw() {
            ctx.save()
            ctx.translate(width / 2, height / 2)
            ctx.rotate(-Math.PI / 2)
            // 内框
            ctx.save()
            ctx.beginPath()
            ctx.arc(0, 0, 145, 0, c)
            ctx.strokeStyle = redA
            ctx.lineWidth = 20
            ctx.stroke()
            ctx.restore()

            // 外框
            ctx.save()
            ctx.beginPath()
            ctx.arc(0, 0, 155, 0, c)
            ctx.strokeStyle = redB
            ctx.lineWidth = 9
            ctx.stroke()
            ctx.restore()

            // 刻度
            ctx.save()
            for (let i = 0; i < 4; i++) {
                ctx.beginPath()
                ctx.moveTo(90, 0)
                ctx.lineTo(120, 0)
                ctx.lineWidth = 15
                ctx.strokeStyle = redB
                ctx.stroke()
                ctx.rotate(c / 4)
            }
            ctx.restore()

            // 小时刻度
            ctx.save()
            for (let i = 0; i < 12; i++) {
                if (i % 3) {
                    ctx.beginPath()
                    ctx.moveTo(90, 0)
                    ctx.lineTo(120, 0)
                    ctx.lineWidth = 6
                    ctx.strokeStyle = yellow
                    ctx.stroke()
                }
                ctx.rotate(c / 12)
            }
            ctx.restore()

            // 分钟刻度
            ctx.save()
            for (let i = 0; i < 60; i++) {
                if (i % 5) {
                    ctx.beginPath()
                    ctx.moveTo(118, 0)
                    ctx.lineTo(120, 0)
                    ctx.lineWidth = 3
                    ctx.strokeStyle = yellow
                    ctx.stroke()
                }
                ctx.rotate(c / 60)
            }
            ctx.restore()

            const { rh, rm, rs } = getRadian()
            // 时针
            ctx.save()
            ctx.rotate(rh)
            ctx.beginPath()
            ctx.moveTo(-20, 0, 0)
            ctx.lineTo(65, 0)
            ctx.lineWidth = 9
            ctx.strokeStyle = yellow
            ctx.stroke()
            ctx.restore()

            // 分针
            ctx.save()
            ctx.rotate(rm)
            ctx.beginPath()
            ctx.moveTo(-28, 0, 0)
            ctx.lineTo(80, 0)
            ctx.lineWidth = 4
            ctx.strokeStyle = yellow
            ctx.stroke()
            ctx.restore()

            // 秒针
            ctx.save()
            ctx.rotate(rs)
            ctx.beginPath()
            ctx.moveTo(-30, 0, 0)
            ctx.lineTo(88, 0)
            ctx.lineWidth = 2
            ctx.strokeStyle = redB
            ctx.stroke()
            ctx.restore()

            // 中心圆
            ctx.save()
            ctx.beginPath()
            ctx.arc(0, 0, 10, 0, c)
            ctx.fillStyle = redB
            ctx.fill()
            ctx.restore()



            ctx.restore()
        }

        //基于当前时间获取时、分、秒针的弧度
        function getRadian() {
            //获取当前时间的时分秒 Date
            const date = new Date();

            //当前小时 getHours
            let h = date.getHours();
            if (h > 12) { h -= 12 }
            //当前分钟 getMinutes
            let m = date.getMinutes();
            //当前秒 getSeconds
            let s = date.getSeconds();

            //时针旋转弧度
            const rh = c * h / 12 + c * m / 12 / 60 + c * s / 12 / 60 / 60;
            //分针旋转弧度
            const rm = c * m / 60 + c * s / 60 / 60;
            //秒针旋转弧度
            const rs = c * s / 60;

            //返回三个弧度
            return { rh, rm, rs };
        }

        !(function render() {
            ctx.clearRect(0, 0, width, height)
            draw()
            requestAnimationFrame(render)
        })()
    </script>
</body>

</html>